## CSS主要样式

CSS样式最常见的就是控制一个容器（div、p、span、li等这些都是容器）的文字样式、高宽度、背景、间距、边框等，比如width:100px就代表这个容器的宽度是100个像素。写CSS样式的时候你可以直接写到容器的style属性上

  
在html标签里面，每个标签都是一个对象，而对象都有他们自己的属性、事件和方法，在你之前做的那个最基础的页面里面，id就是div的一个属性，可以尝试的往div上面添加一个style属性。

## CSS里面常用的样式控制

容器的高度（width）和宽度（weight）比如style="width：200px;height:100px;"

## 块级容器

网页里面最常见的两种容器一种是块级元素一种是行内元素

很多人都叫div，p这些标签块级元素，习惯称它们为容器或者块级容器

块级容器前后有换行符，每个块级容器在页面里面默认显示的时候它的左右不能有其他元素

行内元素就是前后没有换行符，比如span就是行内元素

## 文字样式

文字的颜色（color）、大小(font-size)、加粗(font-weight)、行距(line-height)，比如让你文本颜色为红色(color:#f00)、大小是14px(font-size:14px;)、加粗(font-eight:bold;)、行距(line-height:30px;)

## JS特性

- JS里面的数据类型都是弱类型，也就是说给变量什么类型的值，这个变量就是什么类型

- JS里面的表达式是顺序执行的！也就是说执行完第一行在执行第二行，以此类推！

- JS的函数定义不分前后，哪怕你在页面的最后一行定义函数，在第一行照样可以调用

- JS中定义一个变量如果前面不加var它就是一个全局变量，无论你在函数内还是函数外都是全局的，所以定义变量的时候一定要有一个在变量前面加var的习惯！

## float横向布局

在css样式里面，有一个float属性，它可以给容器靠左或者靠右的趋势。跟你摆放盒子的放法一样，如果float设置成left，容器就会沿着父容器的左上角一个挨着一个排列，当第一行剩余的空间不足以放下一个容器的时候，这个容器就会换行，并且靠左寻找可以放他的位置。

把每一个容器想象成一个铁盒子，在父容器的左侧有一块强力磁铁，如果右侧放不下一个铁盒，这个铁盒会往下移动，直到移动到可以放下它的时候就停止下移，这是左侧还有磁铁对它的吸力，所以它还得继续左移，直到有其他铁盒卡住它为止。

![[Pasted image 20221110113006.png]]
这里的四个容器float都是left，你可以看到，根据mainContainer里面子容器的顺序先放b21，然后放b31，因为当前空余一半的位置，所以b31轻松靠在了b21的右边，第三个要放的是b41，由于b21的宽度加b31的宽度为1/2+1/3，剩余的位置不足以放置b41，所以b41会往下走，当它下移超过b31高度以后剩余的空间可以放它，因此它继续向右靠直到被b21卡住为止。

## js函数

在js里面函数也可以作为一个参数传递，也就是说我们可以定义一个变量，让变量等于一个匿名函数。

一般我们定义函数的时候都是有函数名的，匿名函数就是没有函数名的函数。

![[Pasted image 20221110153515.png]]

没有函数名，它的外部通过小括号括住，如果需要参数传递，后面可以跟一对小括号放参数，如现在这个匿名函数需要传递一个参数a，所以后面有一对小括号里面传递了参数15。匿名函数有一个非常大的好处就是，我们做的一个功能页面如果可能会被别的页面调用，为了避免变量名称冲突，通常在这个页面的js功能通过一个匿名函数来实现，匿名函数内部的变量使用var定义就不会与其他页面同名变量冲突。

![[Pasted image 20221110154019.png]]

这里的两个函数表达的内容是一样的，都可以传递一个参数a，然后在控制台输出myTip+a字符串。唯一的区别就是上面的tipf函数符合代码顺序执行，下面的tipf函数可以在页面任意位置定义。另外在定义js对象的时候也可以用第一种方式通过prototype给对象设定方法。

还有一种函数是有返回值的，返回值使用return关键字

![[Pasted image 20221110154103.png]]

这个res函数有一个参数s，我们传入字符串s以后，函数会返回一个包含span标签的红色文字。直观理解就是，res等于返回值。于是我们如果希望一个div里面放一段红色的文字就不用考虑样式了，只需要直接传递文本就可以。

##  弹层与浮动导航的实现

通过position可以改变容器的定位，这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。

position里面的fixed类型，这个属性值是让容器基于浏览器窗口的绝对定位。

给一个容器设定position为fixed以后，可以通过left、right、bottom、top进行四个方向的距离定位。

![[Pasted image 20221110161207.png]]

在body里面加了一个标识为foot的div，然后他的css里面把position设置成了fixed，并且bottom（距离底部）为0，这里的bottom是基于浏览器窗口的距离进行计算的，foot的宽和高也进行了设定。

![[Pasted image 20221110161259.png]]

拖动滚动条往下滚动网页的时候，foot的位置并不会随着滚动条的滚动发生改变，它就像是漂浮在那里一样。这里的foot是一个div容器，所以它的内部我们还可以放任何你希望布局的内容，比如放一个图片，或者其他的容器。

## JavaScript处理JSON

通过JSON串我们可以很方便的进行数据通信，比如通过ajax去加载一个页面，被加载的页面如果没有html标签只有JSON格式的字符串，我们就可以把JSON串转换为JavaScript对象轻松进行数据处理了。

实际开发的时候JSON串不会像我们现在定义的JSON串那样简单，如果我们要获取一个文章列表页的JSON串，它里面可能会包含栏目的id、栏目标题、文章列表（可能会是一个数组，也可能是一个列表对象）、每页显示条数、文章总数、用户信息（一个对象，它里面又包含用户的昵称、电话、头像等）。

一般从外部加载的JSON串JavaScript会自动把JSON串转换为Object对象，如果是自定义的JSON字符串我们需要使用JSON.parse(JSON串)进行兑现转换。

  
## jQuery的ajax加载外部页面原理

ajax是一个异步请求，异步请求原理很简单：**我问你要东西，你给我东西。**

要东西的时候有这么几种情况：**问谁要、明着要还是悄悄要、要什么、你以什么方式给我、给我以后我怎么处理、我问你要东西你没听见怎么办？**

我们有一个html的静态页面，页面中需要显示后台数据库中的一个用户的信息。现在有一个handle.php页面它可以通过用户的userid从数据库中拿到对应的用户信息，**具体它是怎么处理的数据库你不用关心**，你只需要知道：你要哪个用户的信息、他就会按照特定的JSON格式给你。就像我刚问你要用户反馈表一样，你问handle.php要某个用户的信息，它也需要一定的时间才能给你，当它给了你数据以后你才能对数据进行处理。这个过程就是一个异步过程，我们必须等拿到数据后才能对数据进行处理。

![[Pasted image 20221110162248.png]]

第一个参数url是handle相对于当前页面的地址，这就是**问谁要**。第二个参数type一般传两种参数get（明着要）和post（悄悄要）。第三个参数data是我们要发送给handle的数据，说白了就是刚我们说的**要什么**。第四个参数dataType就是**以什么方式给我**，这里要求的是json格式数据。最后一个参数是success，这个就是**给我以后怎么处理。**这几个参数是我们ajax请求时最常用到的，还有其他很多参数，你可以看看jQuery的ajax参数说明。

通过外部加载的json字符串会默认转换为对象，JSON.stringify()将返回的结果转换成字符串，方便控制台输出查看它的内容。
  
## js中的prototype原型

	一般我们在做页面功能的时候，类基本都是从一个外部js地址加载进来，这个js文件里面可能包含了很多常用的类，我们是不能随便改它们的，因为还有其他的开发人员在引入这些js文件。但是有时我们又希望给这个类添加一个通用的方法，这该怎么办呢？

  
通过点语法直接给Man增加方法，通过添加属性和方法的对象都可以看作是一个个实例（在这里你同样可以给xiaobai和laozhu两个实例动态添加），现在我们是给类添加方法，在这里就不适用了

给类添加方法我们需要用到原型属性（prototype）

`Man.prototype.towhere = function() ={}`

实例是通过new关键字创建的所以不能通过prototype添加。

Array、String上可以使用prototype原型动态添加方法

## canvas
canvas就是一个绘图的容器，我们一样可以通过css对它进行样式控制。

它的核心功能就是位图重绘，它可以把一张图加载到内存中重新绘制到canvas中（注意不是插入，是重新绘制），也可以把一张图加载到内存中进行切片绘制。

比如这张我从网上随便搜的图片，通过canvas可以把这张图分成四个切片，按需绘制，网页游戏里面的任务场景等控制都是通过canvas重绘完成的。

通过document.getElementById('mycanvas')可以拿到canvas对象，如果要在canvas上画图，我们可以使用getContext方法获取绘图对象。
![[Pasted image 20221114164826.png]]

ctx是一个CanvasRenderingContext2D对象，通过ctx我们可以设定绘图的填充色fillStyle、绘制图形fillRect等操作

**canvas在web前端应用中最常用的一个功能——重绘外部图片:**

假如用户上传头像的时候图片格式特别大，我们就可以把头像先在canvas中重绘一下，然后再把重绘好的图片发送到服务器进行保存，这样用户以后使用头像的时候，图片格式就非常小了。

在javascript中有一个Image类，他是用来对图片进行操作的类，我们可以通过实例化一个Image对象来做一些图片的操作。

![[Pasted image 20221114170118.png]]

这段代码实例化了一个img图片对象，通过img的路径（src）属性可是设置图片的路径。在canvas中绘制图片用到的是drawImage(_img_,_sx_,_sy_,_swidth_,_sheight_,_x_,_y_,_width_,_height_)方法，这里第一个参数就是图片对象，sx和sy是裁剪的位置，swidth和sheight是要使用的图片对象的宽度和高度，x和y是图片在canvas中的坐标位置，width和height是最终显示的图片的宽和高。它还有一个重载方法是drawImage(_img_,_x_,_y_），这个方法只考虑图片对象和x轴y轴。

**图片上传：**

图片上传的接口页面一般有两种类型：

	一种是：通过js读取图片流POST发送到接口页面，然后将图片信息写入到服务器上，写入成功以后返回一个成功信息和图片在服务器上的地址信息。

	另一种是：通过Form把图片信息发送给接口页面，然后将图片信息写入到服务器上，写入成功以后返回一个成功信息和图片在服务器上的地址信息。

**图片上传功能之通过js拿到图片信息**

如何选择图片以后把图片放到缩略图容器中进行预览：

这里用jQuery的change方法来检查inpufile内容是否发生了改变，一旦改变就从控制台输出当前选择的文件信息。从输出的结果你大概能理解file对象的构造，file对象包含了最后修改时间（lastModifiedDate）、文件名（name）、文件大小（size）、文件类型（type）等信息。

用一个H5新增的文件读取类FileReader，通过它去读file，拿到文件的内容。

实例化一个fileReader对象fr，通过fr的readAsDataURL方法去读file对象就能拿到图片的base64编码（把图片内容用一个特殊的文本编码呈现出来，图片进行base64编码以后我们就可以通过字符串来表示一个图片了）。
把图片内容用一个特殊的文本编码呈现出来，图片进行base64编码以后我们就可以通过字符串来表示一个图片了

## javascript的匿名函数

![[Pasted image 20221114174507.png]]

严格意义上来说上面那个不是定义一个函数，而是将一个变量指向了一个匿名函数，这里是引用的关系。
![[Pasted image 20221114174552.png]]

匿名函数非常有个特点，匿名函数如果没有被引用，用完后会被销毁，也就是垃圾回收释放内存。如果被引用，而引用它的那个变量一直在内存中，它指向的匿名函数就会一直存在，不会被销毁。

在js中匿名函数还有一个非常重要的用法就是在页面加载以后执行一个匿名函数。
![[Pasted image 20221114174752.png]]

这个函数在页面加载后会立即执行，如果函数有参数，可以通过最后面的小括号进行传参。如果这个页面被其他页面加载调用，这里的匿名函数被加载以后就会立即执行，由于匿名函数中我们使用了var进行变量定义，因此匿名函数中的变量不会与主页面中的变量冲突，匿名函数执行结束以后内部的变量也会被销毁，不会占用内存。

如果你的页面中引入很多其他js文件，为了避免变量冲突，也需要在页面中使用上面的匿名函数来规避风险。

